#include "token_transform_client.hpp"
#include "token_transforms.hpp"

#include "token_transforms_mock.grpc.pb.h"

#include <iostream>
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <memory>
#include <sodium.h>
#include <string>
#include <vector>

namespace epione {
namespace testing {

using std::unique_ptr;
using std::make_unique;
using std::string;
using std::vector;
using std::cout;
using std::endl;

using grpc::Status;

using namespace ::testing;

const unsigned char sample_r_array[] = {
  0x29, 0x9e, 0x1f, 0x23, 0xd0, 0x8b, 0xeb, 0xca,
  0x78, 0x34, 0x39, 0xef, 0x7c, 0xfa, 0x86, 0xee,
  0xc5, 0xda, 0x86, 0x72, 0xbe, 0xa6, 0x9c, 0x39,
  0x5f, 0xcb, 0xde, 0xf9, 0x6c, 0x19, 0x45, 0x07};

const string sample_r((char*)sample_r_array, sizeof(sample_r_array));

const unsigned char sample_k_array[] = {
  0x78, 0x34, 0x39, 0xef, 0x7c, 0xfa, 0x86, 0xee,
  0xc5, 0xda, 0x86, 0x72, 0xbe, 0xa6, 0x9c, 0x39,
  0x29, 0x9e, 0x1f, 0x23, 0xd0, 0x8b, 0xeb, 0xca,
  0x5f, 0xcb, 0xde, 0xf9, 0x6c, 0x19, 0x45, 0x07};

const string sample_k((char*)sample_k_array, sizeof(sample_k_array));

const unsigned char sample_token_array[] = {
    0x33, 0x15, 0x16, 0x23, 0x66, 0x49, 0x04, 0x26,
    0xcc, 0x07, 0xf6, 0xcb, 0x26, 0x9c, 0x4a, 0x51,
    0x02, 0x17, 0x44, 0xfa, 0x2a, 0x1f, 0x0a, 0xa8,
    0x87, 0x53, 0x4a, 0x75, 0x61, 0x33, 0x15, 0x17,
    0xfd, 0xd1, 0x26, 0x99, 0xc2, 0x9e, 0xaa, 0x56,
    0xe8, 0xb6, 0x72, 0x8e, 0xf9, 0xc2, 0xa4, 0x88,
    0xaf, 0xe4, 0xdf, 0x94, 0x34, 0x7b, 0xc1, 0x24,
    0x27, 0x9d, 0x2f, 0xbd, 0xf8, 0x64, 0x41, 0xa0,
    0x2e, 0x8e, 0xd5, 0x60, 0x53, 0x1b, 0xcc, 0xe9,
    0xec, 0xca, 0xdc, 0xae, 0xd7, 0x7f, 0x43, 0x81,
    0x65, 0x23, 0xfe, 0x30, 0xb9, 0x12, 0xa2, 0xe1,
    0x46, 0x2f, 0x47, 0x0c, 0xab, 0xb5, 0xca, 0xc2,
    0x33, 0x55, 0xe8, 0x9f, 0x5f, 0x98, 0x71, 0x8a,
    0x09, 0x7c, 0xc8, 0xec, 0x5c, 0x5e, 0xea, 0x84,
    0x7f, 0x19, 0xfc, 0x26, 0x39, 0xa8, 0x94, 0x1f,
    0x5a, 0xbd, 0x6e, 0x1b, 0x67, 0x93, 0xa2, 0xf3,
    0x4d, 0x3d, 0xf2, 0xad, 0xeb, 0xd2, 0x90, 0x0f,
    0xfd, 0xb2, 0x06, 0x3b, 0x41, 0x01, 0x24, 0x29,
    0xd4, 0xab, 0xc3, 0x3a, 0x62, 0x46, 0x4b, 0x39,
    0xfd, 0x08, 0x16, 0x5b, 0x96, 0x35, 0x48, 0x87};

TEST(TokenTransformClientTest, BlindSingleToken) {
  ASSERT_THAT(sodium_init(), Ge(0));

  vector<string> input_tokens;
  input_tokens.push_back(string((char*)sample_token_array, TOKEN_SIZE));

  TokenSet server_response;
  auto exp_sent_to_server = blind_token(input_tokens[0], sample_r);
  server_response.add_token(blind_element(exp_sent_to_server, sample_k));

  MockTokenBlindingServiceStub* stub = new MockTokenBlindingServiceStub();
  EXPECT_CALL(*stub, Blind(_,_,_)).Times(AtLeast(1))
        .WillOnce(DoAll(SetArgPointee<2>(server_response),
            Return(Status::OK)));

  TokenTransformClient client(
    (unique_ptr<TokenBlindingService::StubInterface>(stub)));
  client.set_r(sample_r);
  auto output_tokens = client.BlindTokens(input_tokens);
  ASSERT_THAT(output_tokens, SizeIs(input_tokens.size()));

  auto expected = blind_token(input_tokens[0], sample_k);
  EXPECT_THAT(output_tokens, ElementsAre(expected));
}

TEST(TokenTransformClientTest, BlindTokenSet) {
  ASSERT_THAT(sodium_init(), Ge(0));

  vector<string> input_tokens;
  TokenSet server_response;
  vector<string> expected_output;
  for (int i = 0; i < sizeof(sample_token_array); i += TOKEN_SIZE) {
    string t((char*)sample_token_array + i, TOKEN_SIZE);
    input_tokens.push_back(t);
    auto exp_sent_to_server = blind_token(t, sample_r);
    server_response.add_token(blind_element(exp_sent_to_server, sample_k));
    expected_output.push_back(blind_token(t, sample_k));
  }

  MockTokenBlindingServiceStub* stub = new MockTokenBlindingServiceStub();
  EXPECT_CALL(*stub, Blind(_,_,_)).Times(AtLeast(1))
        .WillOnce(DoAll(SetArgPointee<2>(server_response),
            Return(Status::OK)));

  TokenTransformClient client(
    (unique_ptr<TokenBlindingService::StubInterface>(stub)));
  client.set_r(sample_r);
  auto output_tokens = client.BlindTokens(input_tokens);
  ASSERT_THAT(output_tokens, SizeIs(input_tokens.size()));

  EXPECT_THAT(output_tokens, ElementsAreArray(expected_output));
}

}  // namespace testing
}  // namespace epione
